import * as pulumi from '@pulumi/pulumi'
import * as cloudflare from '@pulumi/cloudflare'
import * as random from '@pulumi/random'
import { cfAccountId, cfztOrgName, domainName, orgAuthDomain, cfZoneId, cfApiToken } from './config'
import { CfTunnelDrainer } from './tunnel-drainer'

const tunnelSecret = new random.RandomPassword('tunnel-secret', {
  length: 64,
  special: false,
}).result

export const infraTunnel = new cloudflare.ZeroTrustTunnelCloudflared('infra-tunnel', {
  accountId: cfAccountId,
  name: 'infra-tunnel',
  tunnelSecret,
})

// Prevent runtime error about deleting a tunnel still in use
const tunnelDrainer = new CfTunnelDrainer(
  'infra-tunnel-drainer',
  { accountId: cfAccountId, tunnelId: infraTunnel.id, apiToken: cfApiToken },
  { dependsOn: [infraTunnel] },
)

const infraTunnelToken = pulumi
  .all([cfAccountId, infraTunnel.id])
  .apply(([accountId, tunnelId]) =>
    cloudflare.getZeroTrustTunnelCloudflaredToken({ accountId, tunnelId }),
  )
  .apply(res => res.token)

export const createCloudConfig = (
  privateKey: pulumi.Input<string>,
  publicKey: pulumi.Input<string>,
  hostCert: pulumi.Input<string>,
) => pulumi.interpolate`#cloud-config
package_update: false
package_upgrade: false
packages:
  - curl
  - python3

# Write keys to temporary location to avoid conflict with cloud-init's default key generation
write_files:
  - path: /root/my_ssh_host_ed25519_key
    encoding: b64
    content: ${pulumi.output(privateKey).apply(k => Buffer.from(k).toString('base64'))}
    permissions: '0600'
  - path: /root/my_ssh_host_ed25519_key.pub
    encoding: b64
    content: ${pulumi.output(publicKey).apply(k => Buffer.from(k).toString('base64'))}
    permissions: '0644'
  - path: /root/my_ssh_host_ed25519_key-cert.pub
    encoding: b64
    content: ${pulumi.output(hostCert).apply(c => Buffer.from(c).toString('base64'))}
    permissions: '0644'

runcmd:
  # 1. Download Cloudflared
  - curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-arm64.deb
  - dpkg -i cloudflared.deb
  
  # 2. Install CA keys and configure SSH
  # Overwrite any keys generated by cloud-init
  - mv /root/my_ssh_host_ed25519_key /etc/ssh/ssh_host_ed25519_key
  - mv /root/my_ssh_host_ed25519_key.pub /etc/ssh/ssh_host_ed25519_key.pub
  - mv /root/my_ssh_host_ed25519_key-cert.pub /etc/ssh/ssh_host_ed25519_key-cert.pub
  
  # Ensure strict permissions
  - chmod 600 /etc/ssh/ssh_host_ed25519_key
  - chmod 644 /etc/ssh/ssh_host_ed25519_key.pub /etc/ssh/ssh_host_ed25519_key-cert.pub
  - chown root:root /etc/ssh/ssh_host_ed25519_key*
  
  # Configure sshd to use the key and cert
  # We append to sshd_config to override defaults and avoid include-order issues
  - echo "" >> /etc/ssh/sshd_config
  - echo "# Pulumi Managed Keys" >> /etc/ssh/sshd_config
  - echo "HostKey /etc/ssh/ssh_host_ed25519_key" >> /etc/ssh/sshd_config
  - echo "HostCertificate /etc/ssh/ssh_host_ed25519_key-cert.pub" >> /etc/ssh/sshd_config
  
  # 3. Install Tunnel Service
  - cloudflared service install "${infraTunnelToken}"
  - systemctl enable --now cloudflared
  - rm cloudflared.deb
  
  # 4. Restart SSH to apply changes
  - systemctl restart ssh
  - echo "SSH and Tunnel Ready"
`

const team = new cloudflare.ZeroTrustOrganization('main-team', {
  accountId: cfAccountId,
  name: cfztOrgName,
  authDomain: orgAuthDomain,
  autoRedirectToIdentity: true,
})

const orgDomainAccessPolicy = new cloudflare.ZeroTrustAccessPolicy('org-domain-access-policy', {
  accountId: cfAccountId,
  name: 'Allow Only Org Domain',
  decision: 'allow',
  includes: [{ emailDomain: { domain: domainName } }],
})

const appLauncher = new cloudflare.ZeroTrustAccessApplication('app-launcher', {
  accountId: cfAccountId,
  domain: orgAuthDomain,
  name: 'App Launcher',
  sessionDuration: '24h',
  type: 'app_launcher',
  policies: [{ id: orgDomainAccessPolicy.id }],
})

const bastionHostname = pulumi.interpolate`ssh.${domainName}`

new cloudflare.DnsRecord('bastion-ssh-dns', {
  zoneId: cfZoneId,
  name: 'ssh',
  type: 'CNAME',
  content: pulumi.interpolate`${infraTunnel.id}.cfargotunnel.com`,
  proxied: true,
  ttl: 1,
})

new cloudflare.ZeroTrustAccessApplication('bastion-ssh-app', {
  accountId: cfAccountId,
  name: 'SSH Bastion Access',
  domain: bastionHostname,
  type: 'ssh',
  policies: [{ id: orgDomainAccessPolicy.id }],
})

const tunnelIngresses: cloudflare.types.input.ZeroTrustTunnelCloudflaredConfigConfigIngress[] = [
  {
    hostname: bastionHostname,
    service: 'ssh://localhost:22',
  },
  { service: 'http_status:404' },
]

new cloudflare.ZeroTrustTunnelCloudflaredConfig('infra-tunnel-config', {
  accountId: cfAccountId,
  tunnelId: infraTunnel.id,
  config: { ingresses: tunnelIngresses },
})
